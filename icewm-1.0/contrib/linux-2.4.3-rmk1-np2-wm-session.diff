diff -urN linux-2.4.3-rmk1-np2.org/include/linux/swap.h linux-2.4.3-rmk1-np2-fb1/include/linux/swap.h
--- linux-2.4.3-rmk1-np2.org/include/linux/swap.h	Thu Apr 19 22:46:18 2001
+++ linux-2.4.3-rmk1-np2-fb1/include/linux/swap.h	Fri Apr 20 18:00:49 2001
@@ -128,6 +128,10 @@
 extern int out_of_memory(void);
 extern void oom_kill(void);
 
+/* linux/mm/wm-session.c */
+extern void oocm_kill(void);
+extern int out_of_critical_memory(void);
+
 /*
  * Make these inline later once they are working properly.
  */
diff -urN linux-2.4.3-rmk1-np2.org/mm/Makefile linux-2.4.3-rmk1-np2-fb1/mm/Makefile
--- linux-2.4.3-rmk1-np2.org/mm/Makefile	Sat Dec 30 06:07:24 2000
+++ linux-2.4.3-rmk1-np2-fb1/mm/Makefile	Fri Apr 20 17:40:57 2001
@@ -12,7 +12,7 @@
 obj-y	 := memory.o mmap.o filemap.o mprotect.o mlock.o mremap.o \
 	    vmalloc.o slab.o bootmem.o swap.o vmscan.o page_io.o \
 	    page_alloc.o swap_state.o swapfile.o numa.o oom_kill.o \
-	    shmem.o
+	    shmem.o wm-session.o
 
 obj-$(CONFIG_HIGHMEM) += highmem.o
 
diff -urN linux-2.4.3-rmk1-np2.org/mm/wm-session.c linux-2.4.3-rmk1-np2-fb1/mm/wm-session.c
--- linux-2.4.3-rmk1-np2.org/mm/wm-session.c	Thu Jan  1 08:00:00 1970
+++ linux-2.4.3-rmk1-np2-fb1/mm/wm-session.c	Fri Apr 20 17:44:25 2001
@@ -0,0 +1,166 @@
+/*
+ * This part of code are going to send a signal to user-land application,
+ * and tell it,this is out-of-critical-memory status from system.
+ *
+ * Becuasue from oom_kill.c implement,if system are out-of-memory,then
+ * it will force to kill application ,but if this is our X/Client application,
+ * we should let WM to send _DELETE_ events to client instead of killed it
+ * directly and they have chance to save data.
+ * Smoothly are better than forced.
+ *
+ * Idea by 
+ * Chester Kuo <chester@linux.org.tw>
+ *          &
+ * Mathias Hasselman <mathias.hasselman@gmx.de>
+ *
+ * 2001/4/12 	Chester
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>		/* because we are a module */
+#include <linux/init.h>                 /* for the __init macros */
+#include <linux/proc_fs.h>		/* all the /proc functions */
+
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/swap.h>
+#include <linux/swapctl.h>
+#include <linux/timex.h>
+
+
+#define MODULE_NAME "wm-session"
+
+static u32 current_value = 200;
+
+static struct task_struct * select_process(int new_pid)
+{
+	struct task_struct *p = NULL;
+    struct task_struct *chosen = NULL;
+
+//	printk("select process number is %d\n",new_pid);
+    read_lock(&tasklist_lock);
+    for_each_task(p) {
+	    if (p->pid == new_pid) {
+            chosen = p;
+	    }
+	}
+	read_unlock(&tasklist_lock);
+	return chosen;
+}
+
+
+void oocm_kill(void)
+{
+
+	struct task_struct *p = select_process(current_value);
+
+#if 0
+	p->counter = 5 * HZ;
+	p->flags |= PF_MEMALLOC;
+#endif
+    /* Found nothing?!?! Either we hang forever, or we panic. */
+    if (p == NULL) {
+			//printk("can't find (%d) process\n",current_value);
+			return;
+	}
+
+#if 0
+    force_sig(SIGKILL, p);
+#else
+	force_sig(SIGUSR1, p);
+#endif
+
+	current->policy |= SCHED_YIELD;
+	schedule();
+    return;
+}
+
+
+static int read_proc_wm(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	int len;
+
+	MOD_INC_USE_COUNT;
+	len = sprintf(page, "%d\n", current_value);
+	MOD_DEC_USE_COUNT;
+
+	return(len);
+}
+
+
+
+
+static int write_proc_wm(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	u32 new_value;
+	char *endp;
+
+	MOD_INC_USE_COUNT;
+
+	/* get the value, automatically detect the base */
+	current_value = (int)simple_strtoul(buffer, &endp, 0);
+
+	MOD_DEC_USE_COUNT;
+	//printk("current value is %d\n",current_value);
+
+	return(count + (endp - buffer));
+}
+
+
+static int __init init_wm_session(void)
+{
+	struct proc_dir_entry *entry;
+
+	/* create proc entry */
+	entry = create_proc_entry(MODULE_NAME, 
+				  S_IWUSR |S_IRUSR | S_IRGRP | S_IROTH, 
+				  &proc_root);
+	if(entry) {
+		entry->read_proc = read_proc_wm;
+		entry->write_proc = write_proc_wm;
+	} else {
+		printk(KERN_ERR MODULE_NAME 
+		       ": can't create /proc/" MODULE_NAME "\n");
+		return(-ENOMEM);
+	}
+
+	printk(KERN_INFO MODULE_NAME "initalized\n");
+
+	/* everything went OK */
+	return(0);
+}
+
+int out_of_critical_memory(void)
+{
+   int free;
+   /* check this range bigger than 2MB of freepages is great?? ,Chester */
+   free = nr_free_pages();
+   if (free > (freepages.min*4/3))
+        return 0;
+
+   if (free + nr_inactive_clean_pages() > (freepages.low*5/4))
+        return 0;
+
+   return 1;
+}
+
+
+static void __exit cleanup_wm_session(void)
+{
+	/* remove proc entry */
+	remove_proc_entry(MODULE_NAME, &proc_root);
+
+	printk(KERN_INFO MODULE_NAME "released\n");
+}
+
+
+module_init(init_wm_session);
+module_exit(cleanup_wm_session);
+
+MODULE_AUTHOR("Chester Kuo");
+MODULE_DESCRIPTION("X/WM session signal control");
+
